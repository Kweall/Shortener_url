// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ServiceMock implements mm_handlers.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcRedirect          func(ctx context.Context, shortURL string) (s1 string, err error)
	funcRedirectOrigin    string
	inspectFuncRedirect   func(ctx context.Context, shortURL string)
	afterRedirectCounter  uint64
	beforeRedirectCounter uint64
	RedirectMock          mServiceMockRedirect

	funcShortenURL          func(ctx context.Context, originalURL string) (s1 string, err error)
	funcShortenURLOrigin    string
	inspectFuncShortenURL   func(ctx context.Context, originalURL string)
	afterShortenURLCounter  uint64
	beforeShortenURLCounter uint64
	ShortenURLMock          mServiceMockShortenURL
}

// NewServiceMock returns a mock for mm_handlers.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.RedirectMock = mServiceMockRedirect{mock: m}
	m.RedirectMock.callArgs = []*ServiceMockRedirectParams{}

	m.ShortenURLMock = mServiceMockShortenURL{mock: m}
	m.ShortenURLMock.callArgs = []*ServiceMockShortenURLParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockRedirect struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockRedirectExpectation
	expectations       []*ServiceMockRedirectExpectation

	callArgs []*ServiceMockRedirectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockRedirectExpectation specifies expectation struct of the Service.Redirect
type ServiceMockRedirectExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockRedirectParams
	paramPtrs          *ServiceMockRedirectParamPtrs
	expectationOrigins ServiceMockRedirectExpectationOrigins
	results            *ServiceMockRedirectResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockRedirectParams contains parameters of the Service.Redirect
type ServiceMockRedirectParams struct {
	ctx      context.Context
	shortURL string
}

// ServiceMockRedirectParamPtrs contains pointers to parameters of the Service.Redirect
type ServiceMockRedirectParamPtrs struct {
	ctx      *context.Context
	shortURL *string
}

// ServiceMockRedirectResults contains results of the Service.Redirect
type ServiceMockRedirectResults struct {
	s1  string
	err error
}

// ServiceMockRedirectOrigins contains origins of expectations of the Service.Redirect
type ServiceMockRedirectExpectationOrigins struct {
	origin         string
	originCtx      string
	originShortURL string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRedirect *mServiceMockRedirect) Optional() *mServiceMockRedirect {
	mmRedirect.optional = true
	return mmRedirect
}

// Expect sets up expected params for Service.Redirect
func (mmRedirect *mServiceMockRedirect) Expect(ctx context.Context, shortURL string) *mServiceMockRedirect {
	if mmRedirect.mock.funcRedirect != nil {
		mmRedirect.mock.t.Fatalf("ServiceMock.Redirect mock is already set by Set")
	}

	if mmRedirect.defaultExpectation == nil {
		mmRedirect.defaultExpectation = &ServiceMockRedirectExpectation{}
	}

	if mmRedirect.defaultExpectation.paramPtrs != nil {
		mmRedirect.mock.t.Fatalf("ServiceMock.Redirect mock is already set by ExpectParams functions")
	}

	mmRedirect.defaultExpectation.params = &ServiceMockRedirectParams{ctx, shortURL}
	mmRedirect.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRedirect.expectations {
		if minimock.Equal(e.params, mmRedirect.defaultExpectation.params) {
			mmRedirect.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRedirect.defaultExpectation.params)
		}
	}

	return mmRedirect
}

// ExpectCtxParam1 sets up expected param ctx for Service.Redirect
func (mmRedirect *mServiceMockRedirect) ExpectCtxParam1(ctx context.Context) *mServiceMockRedirect {
	if mmRedirect.mock.funcRedirect != nil {
		mmRedirect.mock.t.Fatalf("ServiceMock.Redirect mock is already set by Set")
	}

	if mmRedirect.defaultExpectation == nil {
		mmRedirect.defaultExpectation = &ServiceMockRedirectExpectation{}
	}

	if mmRedirect.defaultExpectation.params != nil {
		mmRedirect.mock.t.Fatalf("ServiceMock.Redirect mock is already set by Expect")
	}

	if mmRedirect.defaultExpectation.paramPtrs == nil {
		mmRedirect.defaultExpectation.paramPtrs = &ServiceMockRedirectParamPtrs{}
	}
	mmRedirect.defaultExpectation.paramPtrs.ctx = &ctx
	mmRedirect.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRedirect
}

// ExpectShortURLParam2 sets up expected param shortURL for Service.Redirect
func (mmRedirect *mServiceMockRedirect) ExpectShortURLParam2(shortURL string) *mServiceMockRedirect {
	if mmRedirect.mock.funcRedirect != nil {
		mmRedirect.mock.t.Fatalf("ServiceMock.Redirect mock is already set by Set")
	}

	if mmRedirect.defaultExpectation == nil {
		mmRedirect.defaultExpectation = &ServiceMockRedirectExpectation{}
	}

	if mmRedirect.defaultExpectation.params != nil {
		mmRedirect.mock.t.Fatalf("ServiceMock.Redirect mock is already set by Expect")
	}

	if mmRedirect.defaultExpectation.paramPtrs == nil {
		mmRedirect.defaultExpectation.paramPtrs = &ServiceMockRedirectParamPtrs{}
	}
	mmRedirect.defaultExpectation.paramPtrs.shortURL = &shortURL
	mmRedirect.defaultExpectation.expectationOrigins.originShortURL = minimock.CallerInfo(1)

	return mmRedirect
}

// Inspect accepts an inspector function that has same arguments as the Service.Redirect
func (mmRedirect *mServiceMockRedirect) Inspect(f func(ctx context.Context, shortURL string)) *mServiceMockRedirect {
	if mmRedirect.mock.inspectFuncRedirect != nil {
		mmRedirect.mock.t.Fatalf("Inspect function is already set for ServiceMock.Redirect")
	}

	mmRedirect.mock.inspectFuncRedirect = f

	return mmRedirect
}

// Return sets up results that will be returned by Service.Redirect
func (mmRedirect *mServiceMockRedirect) Return(s1 string, err error) *ServiceMock {
	if mmRedirect.mock.funcRedirect != nil {
		mmRedirect.mock.t.Fatalf("ServiceMock.Redirect mock is already set by Set")
	}

	if mmRedirect.defaultExpectation == nil {
		mmRedirect.defaultExpectation = &ServiceMockRedirectExpectation{mock: mmRedirect.mock}
	}
	mmRedirect.defaultExpectation.results = &ServiceMockRedirectResults{s1, err}
	mmRedirect.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRedirect.mock
}

// Set uses given function f to mock the Service.Redirect method
func (mmRedirect *mServiceMockRedirect) Set(f func(ctx context.Context, shortURL string) (s1 string, err error)) *ServiceMock {
	if mmRedirect.defaultExpectation != nil {
		mmRedirect.mock.t.Fatalf("Default expectation is already set for the Service.Redirect method")
	}

	if len(mmRedirect.expectations) > 0 {
		mmRedirect.mock.t.Fatalf("Some expectations are already set for the Service.Redirect method")
	}

	mmRedirect.mock.funcRedirect = f
	mmRedirect.mock.funcRedirectOrigin = minimock.CallerInfo(1)
	return mmRedirect.mock
}

// When sets expectation for the Service.Redirect which will trigger the result defined by the following
// Then helper
func (mmRedirect *mServiceMockRedirect) When(ctx context.Context, shortURL string) *ServiceMockRedirectExpectation {
	if mmRedirect.mock.funcRedirect != nil {
		mmRedirect.mock.t.Fatalf("ServiceMock.Redirect mock is already set by Set")
	}

	expectation := &ServiceMockRedirectExpectation{
		mock:               mmRedirect.mock,
		params:             &ServiceMockRedirectParams{ctx, shortURL},
		expectationOrigins: ServiceMockRedirectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRedirect.expectations = append(mmRedirect.expectations, expectation)
	return expectation
}

// Then sets up Service.Redirect return parameters for the expectation previously defined by the When method
func (e *ServiceMockRedirectExpectation) Then(s1 string, err error) *ServiceMock {
	e.results = &ServiceMockRedirectResults{s1, err}
	return e.mock
}

// Times sets number of times Service.Redirect should be invoked
func (mmRedirect *mServiceMockRedirect) Times(n uint64) *mServiceMockRedirect {
	if n == 0 {
		mmRedirect.mock.t.Fatalf("Times of ServiceMock.Redirect mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRedirect.expectedInvocations, n)
	mmRedirect.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRedirect
}

func (mmRedirect *mServiceMockRedirect) invocationsDone() bool {
	if len(mmRedirect.expectations) == 0 && mmRedirect.defaultExpectation == nil && mmRedirect.mock.funcRedirect == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRedirect.mock.afterRedirectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRedirect.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Redirect implements mm_handlers.Service
func (mmRedirect *ServiceMock) Redirect(ctx context.Context, shortURL string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmRedirect.beforeRedirectCounter, 1)
	defer mm_atomic.AddUint64(&mmRedirect.afterRedirectCounter, 1)

	mmRedirect.t.Helper()

	if mmRedirect.inspectFuncRedirect != nil {
		mmRedirect.inspectFuncRedirect(ctx, shortURL)
	}

	mm_params := ServiceMockRedirectParams{ctx, shortURL}

	// Record call args
	mmRedirect.RedirectMock.mutex.Lock()
	mmRedirect.RedirectMock.callArgs = append(mmRedirect.RedirectMock.callArgs, &mm_params)
	mmRedirect.RedirectMock.mutex.Unlock()

	for _, e := range mmRedirect.RedirectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmRedirect.RedirectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRedirect.RedirectMock.defaultExpectation.Counter, 1)
		mm_want := mmRedirect.RedirectMock.defaultExpectation.params
		mm_want_ptrs := mmRedirect.RedirectMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockRedirectParams{ctx, shortURL}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRedirect.t.Errorf("ServiceMock.Redirect got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRedirect.RedirectMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.shortURL != nil && !minimock.Equal(*mm_want_ptrs.shortURL, mm_got.shortURL) {
				mmRedirect.t.Errorf("ServiceMock.Redirect got unexpected parameter shortURL, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRedirect.RedirectMock.defaultExpectation.expectationOrigins.originShortURL, *mm_want_ptrs.shortURL, mm_got.shortURL, minimock.Diff(*mm_want_ptrs.shortURL, mm_got.shortURL))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRedirect.t.Errorf("ServiceMock.Redirect got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRedirect.RedirectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRedirect.RedirectMock.defaultExpectation.results
		if mm_results == nil {
			mmRedirect.t.Fatal("No results are set for the ServiceMock.Redirect")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmRedirect.funcRedirect != nil {
		return mmRedirect.funcRedirect(ctx, shortURL)
	}
	mmRedirect.t.Fatalf("Unexpected call to ServiceMock.Redirect. %v %v", ctx, shortURL)
	return
}

// RedirectAfterCounter returns a count of finished ServiceMock.Redirect invocations
func (mmRedirect *ServiceMock) RedirectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRedirect.afterRedirectCounter)
}

// RedirectBeforeCounter returns a count of ServiceMock.Redirect invocations
func (mmRedirect *ServiceMock) RedirectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRedirect.beforeRedirectCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.Redirect.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRedirect *mServiceMockRedirect) Calls() []*ServiceMockRedirectParams {
	mmRedirect.mutex.RLock()

	argCopy := make([]*ServiceMockRedirectParams, len(mmRedirect.callArgs))
	copy(argCopy, mmRedirect.callArgs)

	mmRedirect.mutex.RUnlock()

	return argCopy
}

// MinimockRedirectDone returns true if the count of the Redirect invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockRedirectDone() bool {
	if m.RedirectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RedirectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RedirectMock.invocationsDone()
}

// MinimockRedirectInspect logs each unmet expectation
func (m *ServiceMock) MinimockRedirectInspect() {
	for _, e := range m.RedirectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.Redirect at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRedirectCounter := mm_atomic.LoadUint64(&m.afterRedirectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RedirectMock.defaultExpectation != nil && afterRedirectCounter < 1 {
		if m.RedirectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.Redirect at\n%s", m.RedirectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.Redirect at\n%s with params: %#v", m.RedirectMock.defaultExpectation.expectationOrigins.origin, *m.RedirectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRedirect != nil && afterRedirectCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Redirect at\n%s", m.funcRedirectOrigin)
	}

	if !m.RedirectMock.invocationsDone() && afterRedirectCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Redirect at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RedirectMock.expectedInvocations), m.RedirectMock.expectedInvocationsOrigin, afterRedirectCounter)
	}
}

type mServiceMockShortenURL struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockShortenURLExpectation
	expectations       []*ServiceMockShortenURLExpectation

	callArgs []*ServiceMockShortenURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockShortenURLExpectation specifies expectation struct of the Service.ShortenURL
type ServiceMockShortenURLExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockShortenURLParams
	paramPtrs          *ServiceMockShortenURLParamPtrs
	expectationOrigins ServiceMockShortenURLExpectationOrigins
	results            *ServiceMockShortenURLResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockShortenURLParams contains parameters of the Service.ShortenURL
type ServiceMockShortenURLParams struct {
	ctx         context.Context
	originalURL string
}

// ServiceMockShortenURLParamPtrs contains pointers to parameters of the Service.ShortenURL
type ServiceMockShortenURLParamPtrs struct {
	ctx         *context.Context
	originalURL *string
}

// ServiceMockShortenURLResults contains results of the Service.ShortenURL
type ServiceMockShortenURLResults struct {
	s1  string
	err error
}

// ServiceMockShortenURLOrigins contains origins of expectations of the Service.ShortenURL
type ServiceMockShortenURLExpectationOrigins struct {
	origin            string
	originCtx         string
	originOriginalURL string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmShortenURL *mServiceMockShortenURL) Optional() *mServiceMockShortenURL {
	mmShortenURL.optional = true
	return mmShortenURL
}

// Expect sets up expected params for Service.ShortenURL
func (mmShortenURL *mServiceMockShortenURL) Expect(ctx context.Context, originalURL string) *mServiceMockShortenURL {
	if mmShortenURL.mock.funcShortenURL != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Set")
	}

	if mmShortenURL.defaultExpectation == nil {
		mmShortenURL.defaultExpectation = &ServiceMockShortenURLExpectation{}
	}

	if mmShortenURL.defaultExpectation.paramPtrs != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by ExpectParams functions")
	}

	mmShortenURL.defaultExpectation.params = &ServiceMockShortenURLParams{ctx, originalURL}
	mmShortenURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmShortenURL.expectations {
		if minimock.Equal(e.params, mmShortenURL.defaultExpectation.params) {
			mmShortenURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmShortenURL.defaultExpectation.params)
		}
	}

	return mmShortenURL
}

// ExpectCtxParam1 sets up expected param ctx for Service.ShortenURL
func (mmShortenURL *mServiceMockShortenURL) ExpectCtxParam1(ctx context.Context) *mServiceMockShortenURL {
	if mmShortenURL.mock.funcShortenURL != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Set")
	}

	if mmShortenURL.defaultExpectation == nil {
		mmShortenURL.defaultExpectation = &ServiceMockShortenURLExpectation{}
	}

	if mmShortenURL.defaultExpectation.params != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Expect")
	}

	if mmShortenURL.defaultExpectation.paramPtrs == nil {
		mmShortenURL.defaultExpectation.paramPtrs = &ServiceMockShortenURLParamPtrs{}
	}
	mmShortenURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmShortenURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmShortenURL
}

// ExpectOriginalURLParam2 sets up expected param originalURL for Service.ShortenURL
func (mmShortenURL *mServiceMockShortenURL) ExpectOriginalURLParam2(originalURL string) *mServiceMockShortenURL {
	if mmShortenURL.mock.funcShortenURL != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Set")
	}

	if mmShortenURL.defaultExpectation == nil {
		mmShortenURL.defaultExpectation = &ServiceMockShortenURLExpectation{}
	}

	if mmShortenURL.defaultExpectation.params != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Expect")
	}

	if mmShortenURL.defaultExpectation.paramPtrs == nil {
		mmShortenURL.defaultExpectation.paramPtrs = &ServiceMockShortenURLParamPtrs{}
	}
	mmShortenURL.defaultExpectation.paramPtrs.originalURL = &originalURL
	mmShortenURL.defaultExpectation.expectationOrigins.originOriginalURL = minimock.CallerInfo(1)

	return mmShortenURL
}

// Inspect accepts an inspector function that has same arguments as the Service.ShortenURL
func (mmShortenURL *mServiceMockShortenURL) Inspect(f func(ctx context.Context, originalURL string)) *mServiceMockShortenURL {
	if mmShortenURL.mock.inspectFuncShortenURL != nil {
		mmShortenURL.mock.t.Fatalf("Inspect function is already set for ServiceMock.ShortenURL")
	}

	mmShortenURL.mock.inspectFuncShortenURL = f

	return mmShortenURL
}

// Return sets up results that will be returned by Service.ShortenURL
func (mmShortenURL *mServiceMockShortenURL) Return(s1 string, err error) *ServiceMock {
	if mmShortenURL.mock.funcShortenURL != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Set")
	}

	if mmShortenURL.defaultExpectation == nil {
		mmShortenURL.defaultExpectation = &ServiceMockShortenURLExpectation{mock: mmShortenURL.mock}
	}
	mmShortenURL.defaultExpectation.results = &ServiceMockShortenURLResults{s1, err}
	mmShortenURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmShortenURL.mock
}

// Set uses given function f to mock the Service.ShortenURL method
func (mmShortenURL *mServiceMockShortenURL) Set(f func(ctx context.Context, originalURL string) (s1 string, err error)) *ServiceMock {
	if mmShortenURL.defaultExpectation != nil {
		mmShortenURL.mock.t.Fatalf("Default expectation is already set for the Service.ShortenURL method")
	}

	if len(mmShortenURL.expectations) > 0 {
		mmShortenURL.mock.t.Fatalf("Some expectations are already set for the Service.ShortenURL method")
	}

	mmShortenURL.mock.funcShortenURL = f
	mmShortenURL.mock.funcShortenURLOrigin = minimock.CallerInfo(1)
	return mmShortenURL.mock
}

// When sets expectation for the Service.ShortenURL which will trigger the result defined by the following
// Then helper
func (mmShortenURL *mServiceMockShortenURL) When(ctx context.Context, originalURL string) *ServiceMockShortenURLExpectation {
	if mmShortenURL.mock.funcShortenURL != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Set")
	}

	expectation := &ServiceMockShortenURLExpectation{
		mock:               mmShortenURL.mock,
		params:             &ServiceMockShortenURLParams{ctx, originalURL},
		expectationOrigins: ServiceMockShortenURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmShortenURL.expectations = append(mmShortenURL.expectations, expectation)
	return expectation
}

// Then sets up Service.ShortenURL return parameters for the expectation previously defined by the When method
func (e *ServiceMockShortenURLExpectation) Then(s1 string, err error) *ServiceMock {
	e.results = &ServiceMockShortenURLResults{s1, err}
	return e.mock
}

// Times sets number of times Service.ShortenURL should be invoked
func (mmShortenURL *mServiceMockShortenURL) Times(n uint64) *mServiceMockShortenURL {
	if n == 0 {
		mmShortenURL.mock.t.Fatalf("Times of ServiceMock.ShortenURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmShortenURL.expectedInvocations, n)
	mmShortenURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmShortenURL
}

func (mmShortenURL *mServiceMockShortenURL) invocationsDone() bool {
	if len(mmShortenURL.expectations) == 0 && mmShortenURL.defaultExpectation == nil && mmShortenURL.mock.funcShortenURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmShortenURL.mock.afterShortenURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmShortenURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ShortenURL implements mm_handlers.Service
func (mmShortenURL *ServiceMock) ShortenURL(ctx context.Context, originalURL string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmShortenURL.beforeShortenURLCounter, 1)
	defer mm_atomic.AddUint64(&mmShortenURL.afterShortenURLCounter, 1)

	mmShortenURL.t.Helper()

	if mmShortenURL.inspectFuncShortenURL != nil {
		mmShortenURL.inspectFuncShortenURL(ctx, originalURL)
	}

	mm_params := ServiceMockShortenURLParams{ctx, originalURL}

	// Record call args
	mmShortenURL.ShortenURLMock.mutex.Lock()
	mmShortenURL.ShortenURLMock.callArgs = append(mmShortenURL.ShortenURLMock.callArgs, &mm_params)
	mmShortenURL.ShortenURLMock.mutex.Unlock()

	for _, e := range mmShortenURL.ShortenURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmShortenURL.ShortenURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShortenURL.ShortenURLMock.defaultExpectation.Counter, 1)
		mm_want := mmShortenURL.ShortenURLMock.defaultExpectation.params
		mm_want_ptrs := mmShortenURL.ShortenURLMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockShortenURLParams{ctx, originalURL}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmShortenURL.t.Errorf("ServiceMock.ShortenURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmShortenURL.ShortenURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.originalURL != nil && !minimock.Equal(*mm_want_ptrs.originalURL, mm_got.originalURL) {
				mmShortenURL.t.Errorf("ServiceMock.ShortenURL got unexpected parameter originalURL, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmShortenURL.ShortenURLMock.defaultExpectation.expectationOrigins.originOriginalURL, *mm_want_ptrs.originalURL, mm_got.originalURL, minimock.Diff(*mm_want_ptrs.originalURL, mm_got.originalURL))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmShortenURL.t.Errorf("ServiceMock.ShortenURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmShortenURL.ShortenURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmShortenURL.ShortenURLMock.defaultExpectation.results
		if mm_results == nil {
			mmShortenURL.t.Fatal("No results are set for the ServiceMock.ShortenURL")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmShortenURL.funcShortenURL != nil {
		return mmShortenURL.funcShortenURL(ctx, originalURL)
	}
	mmShortenURL.t.Fatalf("Unexpected call to ServiceMock.ShortenURL. %v %v", ctx, originalURL)
	return
}

// ShortenURLAfterCounter returns a count of finished ServiceMock.ShortenURL invocations
func (mmShortenURL *ServiceMock) ShortenURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShortenURL.afterShortenURLCounter)
}

// ShortenURLBeforeCounter returns a count of ServiceMock.ShortenURL invocations
func (mmShortenURL *ServiceMock) ShortenURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShortenURL.beforeShortenURLCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ShortenURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmShortenURL *mServiceMockShortenURL) Calls() []*ServiceMockShortenURLParams {
	mmShortenURL.mutex.RLock()

	argCopy := make([]*ServiceMockShortenURLParams, len(mmShortenURL.callArgs))
	copy(argCopy, mmShortenURL.callArgs)

	mmShortenURL.mutex.RUnlock()

	return argCopy
}

// MinimockShortenURLDone returns true if the count of the ShortenURL invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockShortenURLDone() bool {
	if m.ShortenURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ShortenURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ShortenURLMock.invocationsDone()
}

// MinimockShortenURLInspect logs each unmet expectation
func (m *ServiceMock) MinimockShortenURLInspect() {
	for _, e := range m.ShortenURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ShortenURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterShortenURLCounter := mm_atomic.LoadUint64(&m.afterShortenURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ShortenURLMock.defaultExpectation != nil && afterShortenURLCounter < 1 {
		if m.ShortenURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ShortenURL at\n%s", m.ShortenURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ShortenURL at\n%s with params: %#v", m.ShortenURLMock.defaultExpectation.expectationOrigins.origin, *m.ShortenURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShortenURL != nil && afterShortenURLCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ShortenURL at\n%s", m.funcShortenURLOrigin)
	}

	if !m.ShortenURLMock.invocationsDone() && afterShortenURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ShortenURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ShortenURLMock.expectedInvocations), m.ShortenURLMock.expectedInvocationsOrigin, afterShortenURLCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockRedirectInspect()

			m.MinimockShortenURLInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockRedirectDone() &&
		m.MinimockShortenURLDone()
}
