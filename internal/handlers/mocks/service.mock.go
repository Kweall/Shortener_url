// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ServiceMock implements mm_handlers.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcOriginalURL          func(ctx context.Context, shortURL string) (s1 string, err error)
	funcOriginalURLOrigin    string
	inspectFuncOriginalURL   func(ctx context.Context, shortURL string)
	afterOriginalURLCounter  uint64
	beforeOriginalURLCounter uint64
	OriginalURLMock          mServiceMockOriginalURL

	funcShortenURL          func(ctx context.Context, originalURL string) (s1 string, err error)
	funcShortenURLOrigin    string
	inspectFuncShortenURL   func(ctx context.Context, originalURL string)
	afterShortenURLCounter  uint64
	beforeShortenURLCounter uint64
	ShortenURLMock          mServiceMockShortenURL
}

// NewServiceMock returns a mock for mm_handlers.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.OriginalURLMock = mServiceMockOriginalURL{mock: m}
	m.OriginalURLMock.callArgs = []*ServiceMockOriginalURLParams{}

	m.ShortenURLMock = mServiceMockShortenURL{mock: m}
	m.ShortenURLMock.callArgs = []*ServiceMockShortenURLParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockOriginalURL struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockOriginalURLExpectation
	expectations       []*ServiceMockOriginalURLExpectation

	callArgs []*ServiceMockOriginalURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockOriginalURLExpectation specifies expectation struct of the Service.OriginalURL
type ServiceMockOriginalURLExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockOriginalURLParams
	paramPtrs          *ServiceMockOriginalURLParamPtrs
	expectationOrigins ServiceMockOriginalURLExpectationOrigins
	results            *ServiceMockOriginalURLResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockOriginalURLParams contains parameters of the Service.OriginalURL
type ServiceMockOriginalURLParams struct {
	ctx      context.Context
	shortURL string
}

// ServiceMockOriginalURLParamPtrs contains pointers to parameters of the Service.OriginalURL
type ServiceMockOriginalURLParamPtrs struct {
	ctx      *context.Context
	shortURL *string
}

// ServiceMockOriginalURLResults contains results of the Service.OriginalURL
type ServiceMockOriginalURLResults struct {
	s1  string
	err error
}

// ServiceMockOriginalURLOrigins contains origins of expectations of the Service.OriginalURL
type ServiceMockOriginalURLExpectationOrigins struct {
	origin         string
	originCtx      string
	originShortURL string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOriginalURL *mServiceMockOriginalURL) Optional() *mServiceMockOriginalURL {
	mmOriginalURL.optional = true
	return mmOriginalURL
}

// Expect sets up expected params for Service.OriginalURL
func (mmOriginalURL *mServiceMockOriginalURL) Expect(ctx context.Context, shortURL string) *mServiceMockOriginalURL {
	if mmOriginalURL.mock.funcOriginalURL != nil {
		mmOriginalURL.mock.t.Fatalf("ServiceMock.OriginalURL mock is already set by Set")
	}

	if mmOriginalURL.defaultExpectation == nil {
		mmOriginalURL.defaultExpectation = &ServiceMockOriginalURLExpectation{}
	}

	if mmOriginalURL.defaultExpectation.paramPtrs != nil {
		mmOriginalURL.mock.t.Fatalf("ServiceMock.OriginalURL mock is already set by ExpectParams functions")
	}

	mmOriginalURL.defaultExpectation.params = &ServiceMockOriginalURLParams{ctx, shortURL}
	mmOriginalURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOriginalURL.expectations {
		if minimock.Equal(e.params, mmOriginalURL.defaultExpectation.params) {
			mmOriginalURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOriginalURL.defaultExpectation.params)
		}
	}

	return mmOriginalURL
}

// ExpectCtxParam1 sets up expected param ctx for Service.OriginalURL
func (mmOriginalURL *mServiceMockOriginalURL) ExpectCtxParam1(ctx context.Context) *mServiceMockOriginalURL {
	if mmOriginalURL.mock.funcOriginalURL != nil {
		mmOriginalURL.mock.t.Fatalf("ServiceMock.OriginalURL mock is already set by Set")
	}

	if mmOriginalURL.defaultExpectation == nil {
		mmOriginalURL.defaultExpectation = &ServiceMockOriginalURLExpectation{}
	}

	if mmOriginalURL.defaultExpectation.params != nil {
		mmOriginalURL.mock.t.Fatalf("ServiceMock.OriginalURL mock is already set by Expect")
	}

	if mmOriginalURL.defaultExpectation.paramPtrs == nil {
		mmOriginalURL.defaultExpectation.paramPtrs = &ServiceMockOriginalURLParamPtrs{}
	}
	mmOriginalURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmOriginalURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOriginalURL
}

// ExpectShortURLParam2 sets up expected param shortURL for Service.OriginalURL
func (mmOriginalURL *mServiceMockOriginalURL) ExpectShortURLParam2(shortURL string) *mServiceMockOriginalURL {
	if mmOriginalURL.mock.funcOriginalURL != nil {
		mmOriginalURL.mock.t.Fatalf("ServiceMock.OriginalURL mock is already set by Set")
	}

	if mmOriginalURL.defaultExpectation == nil {
		mmOriginalURL.defaultExpectation = &ServiceMockOriginalURLExpectation{}
	}

	if mmOriginalURL.defaultExpectation.params != nil {
		mmOriginalURL.mock.t.Fatalf("ServiceMock.OriginalURL mock is already set by Expect")
	}

	if mmOriginalURL.defaultExpectation.paramPtrs == nil {
		mmOriginalURL.defaultExpectation.paramPtrs = &ServiceMockOriginalURLParamPtrs{}
	}
	mmOriginalURL.defaultExpectation.paramPtrs.shortURL = &shortURL
	mmOriginalURL.defaultExpectation.expectationOrigins.originShortURL = minimock.CallerInfo(1)

	return mmOriginalURL
}

// Inspect accepts an inspector function that has same arguments as the Service.OriginalURL
func (mmOriginalURL *mServiceMockOriginalURL) Inspect(f func(ctx context.Context, shortURL string)) *mServiceMockOriginalURL {
	if mmOriginalURL.mock.inspectFuncOriginalURL != nil {
		mmOriginalURL.mock.t.Fatalf("Inspect function is already set for ServiceMock.OriginalURL")
	}

	mmOriginalURL.mock.inspectFuncOriginalURL = f

	return mmOriginalURL
}

// Return sets up results that will be returned by Service.OriginalURL
func (mmOriginalURL *mServiceMockOriginalURL) Return(s1 string, err error) *ServiceMock {
	if mmOriginalURL.mock.funcOriginalURL != nil {
		mmOriginalURL.mock.t.Fatalf("ServiceMock.OriginalURL mock is already set by Set")
	}

	if mmOriginalURL.defaultExpectation == nil {
		mmOriginalURL.defaultExpectation = &ServiceMockOriginalURLExpectation{mock: mmOriginalURL.mock}
	}
	mmOriginalURL.defaultExpectation.results = &ServiceMockOriginalURLResults{s1, err}
	mmOriginalURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOriginalURL.mock
}

// Set uses given function f to mock the Service.OriginalURL method
func (mmOriginalURL *mServiceMockOriginalURL) Set(f func(ctx context.Context, shortURL string) (s1 string, err error)) *ServiceMock {
	if mmOriginalURL.defaultExpectation != nil {
		mmOriginalURL.mock.t.Fatalf("Default expectation is already set for the Service.OriginalURL method")
	}

	if len(mmOriginalURL.expectations) > 0 {
		mmOriginalURL.mock.t.Fatalf("Some expectations are already set for the Service.OriginalURL method")
	}

	mmOriginalURL.mock.funcOriginalURL = f
	mmOriginalURL.mock.funcOriginalURLOrigin = minimock.CallerInfo(1)
	return mmOriginalURL.mock
}

// When sets expectation for the Service.OriginalURL which will trigger the result defined by the following
// Then helper
func (mmOriginalURL *mServiceMockOriginalURL) When(ctx context.Context, shortURL string) *ServiceMockOriginalURLExpectation {
	if mmOriginalURL.mock.funcOriginalURL != nil {
		mmOriginalURL.mock.t.Fatalf("ServiceMock.OriginalURL mock is already set by Set")
	}

	expectation := &ServiceMockOriginalURLExpectation{
		mock:               mmOriginalURL.mock,
		params:             &ServiceMockOriginalURLParams{ctx, shortURL},
		expectationOrigins: ServiceMockOriginalURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOriginalURL.expectations = append(mmOriginalURL.expectations, expectation)
	return expectation
}

// Then sets up Service.OriginalURL return parameters for the expectation previously defined by the When method
func (e *ServiceMockOriginalURLExpectation) Then(s1 string, err error) *ServiceMock {
	e.results = &ServiceMockOriginalURLResults{s1, err}
	return e.mock
}

// Times sets number of times Service.OriginalURL should be invoked
func (mmOriginalURL *mServiceMockOriginalURL) Times(n uint64) *mServiceMockOriginalURL {
	if n == 0 {
		mmOriginalURL.mock.t.Fatalf("Times of ServiceMock.OriginalURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOriginalURL.expectedInvocations, n)
	mmOriginalURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOriginalURL
}

func (mmOriginalURL *mServiceMockOriginalURL) invocationsDone() bool {
	if len(mmOriginalURL.expectations) == 0 && mmOriginalURL.defaultExpectation == nil && mmOriginalURL.mock.funcOriginalURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOriginalURL.mock.afterOriginalURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOriginalURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OriginalURL implements mm_handlers.Service
func (mmOriginalURL *ServiceMock) OriginalURL(ctx context.Context, shortURL string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmOriginalURL.beforeOriginalURLCounter, 1)
	defer mm_atomic.AddUint64(&mmOriginalURL.afterOriginalURLCounter, 1)

	mmOriginalURL.t.Helper()

	if mmOriginalURL.inspectFuncOriginalURL != nil {
		mmOriginalURL.inspectFuncOriginalURL(ctx, shortURL)
	}

	mm_params := ServiceMockOriginalURLParams{ctx, shortURL}

	// Record call args
	mmOriginalURL.OriginalURLMock.mutex.Lock()
	mmOriginalURL.OriginalURLMock.callArgs = append(mmOriginalURL.OriginalURLMock.callArgs, &mm_params)
	mmOriginalURL.OriginalURLMock.mutex.Unlock()

	for _, e := range mmOriginalURL.OriginalURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmOriginalURL.OriginalURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOriginalURL.OriginalURLMock.defaultExpectation.Counter, 1)
		mm_want := mmOriginalURL.OriginalURLMock.defaultExpectation.params
		mm_want_ptrs := mmOriginalURL.OriginalURLMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockOriginalURLParams{ctx, shortURL}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOriginalURL.t.Errorf("ServiceMock.OriginalURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOriginalURL.OriginalURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.shortURL != nil && !minimock.Equal(*mm_want_ptrs.shortURL, mm_got.shortURL) {
				mmOriginalURL.t.Errorf("ServiceMock.OriginalURL got unexpected parameter shortURL, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOriginalURL.OriginalURLMock.defaultExpectation.expectationOrigins.originShortURL, *mm_want_ptrs.shortURL, mm_got.shortURL, minimock.Diff(*mm_want_ptrs.shortURL, mm_got.shortURL))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOriginalURL.t.Errorf("ServiceMock.OriginalURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOriginalURL.OriginalURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOriginalURL.OriginalURLMock.defaultExpectation.results
		if mm_results == nil {
			mmOriginalURL.t.Fatal("No results are set for the ServiceMock.OriginalURL")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmOriginalURL.funcOriginalURL != nil {
		return mmOriginalURL.funcOriginalURL(ctx, shortURL)
	}
	mmOriginalURL.t.Fatalf("Unexpected call to ServiceMock.OriginalURL. %v %v", ctx, shortURL)
	return
}

// OriginalURLAfterCounter returns a count of finished ServiceMock.OriginalURL invocations
func (mmOriginalURL *ServiceMock) OriginalURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOriginalURL.afterOriginalURLCounter)
}

// OriginalURLBeforeCounter returns a count of ServiceMock.OriginalURL invocations
func (mmOriginalURL *ServiceMock) OriginalURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOriginalURL.beforeOriginalURLCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.OriginalURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOriginalURL *mServiceMockOriginalURL) Calls() []*ServiceMockOriginalURLParams {
	mmOriginalURL.mutex.RLock()

	argCopy := make([]*ServiceMockOriginalURLParams, len(mmOriginalURL.callArgs))
	copy(argCopy, mmOriginalURL.callArgs)

	mmOriginalURL.mutex.RUnlock()

	return argCopy
}

// MinimockOriginalURLDone returns true if the count of the OriginalURL invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockOriginalURLDone() bool {
	if m.OriginalURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OriginalURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OriginalURLMock.invocationsDone()
}

// MinimockOriginalURLInspect logs each unmet expectation
func (m *ServiceMock) MinimockOriginalURLInspect() {
	for _, e := range m.OriginalURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.OriginalURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOriginalURLCounter := mm_atomic.LoadUint64(&m.afterOriginalURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OriginalURLMock.defaultExpectation != nil && afterOriginalURLCounter < 1 {
		if m.OriginalURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.OriginalURL at\n%s", m.OriginalURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.OriginalURL at\n%s with params: %#v", m.OriginalURLMock.defaultExpectation.expectationOrigins.origin, *m.OriginalURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOriginalURL != nil && afterOriginalURLCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.OriginalURL at\n%s", m.funcOriginalURLOrigin)
	}

	if !m.OriginalURLMock.invocationsDone() && afterOriginalURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.OriginalURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OriginalURLMock.expectedInvocations), m.OriginalURLMock.expectedInvocationsOrigin, afterOriginalURLCounter)
	}
}

type mServiceMockShortenURL struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockShortenURLExpectation
	expectations       []*ServiceMockShortenURLExpectation

	callArgs []*ServiceMockShortenURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockShortenURLExpectation specifies expectation struct of the Service.ShortenURL
type ServiceMockShortenURLExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockShortenURLParams
	paramPtrs          *ServiceMockShortenURLParamPtrs
	expectationOrigins ServiceMockShortenURLExpectationOrigins
	results            *ServiceMockShortenURLResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockShortenURLParams contains parameters of the Service.ShortenURL
type ServiceMockShortenURLParams struct {
	ctx         context.Context
	originalURL string
}

// ServiceMockShortenURLParamPtrs contains pointers to parameters of the Service.ShortenURL
type ServiceMockShortenURLParamPtrs struct {
	ctx         *context.Context
	originalURL *string
}

// ServiceMockShortenURLResults contains results of the Service.ShortenURL
type ServiceMockShortenURLResults struct {
	s1  string
	err error
}

// ServiceMockShortenURLOrigins contains origins of expectations of the Service.ShortenURL
type ServiceMockShortenURLExpectationOrigins struct {
	origin            string
	originCtx         string
	originOriginalURL string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmShortenURL *mServiceMockShortenURL) Optional() *mServiceMockShortenURL {
	mmShortenURL.optional = true
	return mmShortenURL
}

// Expect sets up expected params for Service.ShortenURL
func (mmShortenURL *mServiceMockShortenURL) Expect(ctx context.Context, originalURL string) *mServiceMockShortenURL {
	if mmShortenURL.mock.funcShortenURL != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Set")
	}

	if mmShortenURL.defaultExpectation == nil {
		mmShortenURL.defaultExpectation = &ServiceMockShortenURLExpectation{}
	}

	if mmShortenURL.defaultExpectation.paramPtrs != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by ExpectParams functions")
	}

	mmShortenURL.defaultExpectation.params = &ServiceMockShortenURLParams{ctx, originalURL}
	mmShortenURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmShortenURL.expectations {
		if minimock.Equal(e.params, mmShortenURL.defaultExpectation.params) {
			mmShortenURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmShortenURL.defaultExpectation.params)
		}
	}

	return mmShortenURL
}

// ExpectCtxParam1 sets up expected param ctx for Service.ShortenURL
func (mmShortenURL *mServiceMockShortenURL) ExpectCtxParam1(ctx context.Context) *mServiceMockShortenURL {
	if mmShortenURL.mock.funcShortenURL != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Set")
	}

	if mmShortenURL.defaultExpectation == nil {
		mmShortenURL.defaultExpectation = &ServiceMockShortenURLExpectation{}
	}

	if mmShortenURL.defaultExpectation.params != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Expect")
	}

	if mmShortenURL.defaultExpectation.paramPtrs == nil {
		mmShortenURL.defaultExpectation.paramPtrs = &ServiceMockShortenURLParamPtrs{}
	}
	mmShortenURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmShortenURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmShortenURL
}

// ExpectOriginalURLParam2 sets up expected param originalURL for Service.ShortenURL
func (mmShortenURL *mServiceMockShortenURL) ExpectOriginalURLParam2(originalURL string) *mServiceMockShortenURL {
	if mmShortenURL.mock.funcShortenURL != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Set")
	}

	if mmShortenURL.defaultExpectation == nil {
		mmShortenURL.defaultExpectation = &ServiceMockShortenURLExpectation{}
	}

	if mmShortenURL.defaultExpectation.params != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Expect")
	}

	if mmShortenURL.defaultExpectation.paramPtrs == nil {
		mmShortenURL.defaultExpectation.paramPtrs = &ServiceMockShortenURLParamPtrs{}
	}
	mmShortenURL.defaultExpectation.paramPtrs.originalURL = &originalURL
	mmShortenURL.defaultExpectation.expectationOrigins.originOriginalURL = minimock.CallerInfo(1)

	return mmShortenURL
}

// Inspect accepts an inspector function that has same arguments as the Service.ShortenURL
func (mmShortenURL *mServiceMockShortenURL) Inspect(f func(ctx context.Context, originalURL string)) *mServiceMockShortenURL {
	if mmShortenURL.mock.inspectFuncShortenURL != nil {
		mmShortenURL.mock.t.Fatalf("Inspect function is already set for ServiceMock.ShortenURL")
	}

	mmShortenURL.mock.inspectFuncShortenURL = f

	return mmShortenURL
}

// Return sets up results that will be returned by Service.ShortenURL
func (mmShortenURL *mServiceMockShortenURL) Return(s1 string, err error) *ServiceMock {
	if mmShortenURL.mock.funcShortenURL != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Set")
	}

	if mmShortenURL.defaultExpectation == nil {
		mmShortenURL.defaultExpectation = &ServiceMockShortenURLExpectation{mock: mmShortenURL.mock}
	}
	mmShortenURL.defaultExpectation.results = &ServiceMockShortenURLResults{s1, err}
	mmShortenURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmShortenURL.mock
}

// Set uses given function f to mock the Service.ShortenURL method
func (mmShortenURL *mServiceMockShortenURL) Set(f func(ctx context.Context, originalURL string) (s1 string, err error)) *ServiceMock {
	if mmShortenURL.defaultExpectation != nil {
		mmShortenURL.mock.t.Fatalf("Default expectation is already set for the Service.ShortenURL method")
	}

	if len(mmShortenURL.expectations) > 0 {
		mmShortenURL.mock.t.Fatalf("Some expectations are already set for the Service.ShortenURL method")
	}

	mmShortenURL.mock.funcShortenURL = f
	mmShortenURL.mock.funcShortenURLOrigin = minimock.CallerInfo(1)
	return mmShortenURL.mock
}

// When sets expectation for the Service.ShortenURL which will trigger the result defined by the following
// Then helper
func (mmShortenURL *mServiceMockShortenURL) When(ctx context.Context, originalURL string) *ServiceMockShortenURLExpectation {
	if mmShortenURL.mock.funcShortenURL != nil {
		mmShortenURL.mock.t.Fatalf("ServiceMock.ShortenURL mock is already set by Set")
	}

	expectation := &ServiceMockShortenURLExpectation{
		mock:               mmShortenURL.mock,
		params:             &ServiceMockShortenURLParams{ctx, originalURL},
		expectationOrigins: ServiceMockShortenURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmShortenURL.expectations = append(mmShortenURL.expectations, expectation)
	return expectation
}

// Then sets up Service.ShortenURL return parameters for the expectation previously defined by the When method
func (e *ServiceMockShortenURLExpectation) Then(s1 string, err error) *ServiceMock {
	e.results = &ServiceMockShortenURLResults{s1, err}
	return e.mock
}

// Times sets number of times Service.ShortenURL should be invoked
func (mmShortenURL *mServiceMockShortenURL) Times(n uint64) *mServiceMockShortenURL {
	if n == 0 {
		mmShortenURL.mock.t.Fatalf("Times of ServiceMock.ShortenURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmShortenURL.expectedInvocations, n)
	mmShortenURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmShortenURL
}

func (mmShortenURL *mServiceMockShortenURL) invocationsDone() bool {
	if len(mmShortenURL.expectations) == 0 && mmShortenURL.defaultExpectation == nil && mmShortenURL.mock.funcShortenURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmShortenURL.mock.afterShortenURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmShortenURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ShortenURL implements mm_handlers.Service
func (mmShortenURL *ServiceMock) ShortenURL(ctx context.Context, originalURL string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmShortenURL.beforeShortenURLCounter, 1)
	defer mm_atomic.AddUint64(&mmShortenURL.afterShortenURLCounter, 1)

	mmShortenURL.t.Helper()

	if mmShortenURL.inspectFuncShortenURL != nil {
		mmShortenURL.inspectFuncShortenURL(ctx, originalURL)
	}

	mm_params := ServiceMockShortenURLParams{ctx, originalURL}

	// Record call args
	mmShortenURL.ShortenURLMock.mutex.Lock()
	mmShortenURL.ShortenURLMock.callArgs = append(mmShortenURL.ShortenURLMock.callArgs, &mm_params)
	mmShortenURL.ShortenURLMock.mutex.Unlock()

	for _, e := range mmShortenURL.ShortenURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmShortenURL.ShortenURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShortenURL.ShortenURLMock.defaultExpectation.Counter, 1)
		mm_want := mmShortenURL.ShortenURLMock.defaultExpectation.params
		mm_want_ptrs := mmShortenURL.ShortenURLMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockShortenURLParams{ctx, originalURL}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmShortenURL.t.Errorf("ServiceMock.ShortenURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmShortenURL.ShortenURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.originalURL != nil && !minimock.Equal(*mm_want_ptrs.originalURL, mm_got.originalURL) {
				mmShortenURL.t.Errorf("ServiceMock.ShortenURL got unexpected parameter originalURL, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmShortenURL.ShortenURLMock.defaultExpectation.expectationOrigins.originOriginalURL, *mm_want_ptrs.originalURL, mm_got.originalURL, minimock.Diff(*mm_want_ptrs.originalURL, mm_got.originalURL))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmShortenURL.t.Errorf("ServiceMock.ShortenURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmShortenURL.ShortenURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmShortenURL.ShortenURLMock.defaultExpectation.results
		if mm_results == nil {
			mmShortenURL.t.Fatal("No results are set for the ServiceMock.ShortenURL")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmShortenURL.funcShortenURL != nil {
		return mmShortenURL.funcShortenURL(ctx, originalURL)
	}
	mmShortenURL.t.Fatalf("Unexpected call to ServiceMock.ShortenURL. %v %v", ctx, originalURL)
	return
}

// ShortenURLAfterCounter returns a count of finished ServiceMock.ShortenURL invocations
func (mmShortenURL *ServiceMock) ShortenURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShortenURL.afterShortenURLCounter)
}

// ShortenURLBeforeCounter returns a count of ServiceMock.ShortenURL invocations
func (mmShortenURL *ServiceMock) ShortenURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShortenURL.beforeShortenURLCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ShortenURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmShortenURL *mServiceMockShortenURL) Calls() []*ServiceMockShortenURLParams {
	mmShortenURL.mutex.RLock()

	argCopy := make([]*ServiceMockShortenURLParams, len(mmShortenURL.callArgs))
	copy(argCopy, mmShortenURL.callArgs)

	mmShortenURL.mutex.RUnlock()

	return argCopy
}

// MinimockShortenURLDone returns true if the count of the ShortenURL invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockShortenURLDone() bool {
	if m.ShortenURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ShortenURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ShortenURLMock.invocationsDone()
}

// MinimockShortenURLInspect logs each unmet expectation
func (m *ServiceMock) MinimockShortenURLInspect() {
	for _, e := range m.ShortenURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ShortenURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterShortenURLCounter := mm_atomic.LoadUint64(&m.afterShortenURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ShortenURLMock.defaultExpectation != nil && afterShortenURLCounter < 1 {
		if m.ShortenURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ShortenURL at\n%s", m.ShortenURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ShortenURL at\n%s with params: %#v", m.ShortenURLMock.defaultExpectation.expectationOrigins.origin, *m.ShortenURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShortenURL != nil && afterShortenURLCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ShortenURL at\n%s", m.funcShortenURLOrigin)
	}

	if !m.ShortenURLMock.invocationsDone() && afterShortenURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ShortenURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ShortenURLMock.expectedInvocations), m.ShortenURLMock.expectedInvocationsOrigin, afterShortenURLCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockOriginalURLInspect()

			m.MinimockShortenURLInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockOriginalURLDone() &&
		m.MinimockShortenURLDone()
}
