// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i ozon/internal/storage.Storage -o storage_mock.go -n StorageMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StorageMock implements mm_storage.Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetOriginalURL          func(ctx context.Context, shortURL string) (s1 string, err error)
	funcGetOriginalURLOrigin    string
	inspectFuncGetOriginalURL   func(ctx context.Context, shortURL string)
	afterGetOriginalURLCounter  uint64
	beforeGetOriginalURLCounter uint64
	GetOriginalURLMock          mStorageMockGetOriginalURL

	funcGetShortURL          func(ctx context.Context, originalURL string) (s1 string, err error)
	funcGetShortURLOrigin    string
	inspectFuncGetShortURL   func(ctx context.Context, originalURL string)
	afterGetShortURLCounter  uint64
	beforeGetShortURLCounter uint64
	GetShortURLMock          mStorageMockGetShortURL

	funcSaveURL          func(ctx context.Context, originalURL string, shortURL string) (err error)
	funcSaveURLOrigin    string
	inspectFuncSaveURL   func(ctx context.Context, originalURL string, shortURL string)
	afterSaveURLCounter  uint64
	beforeSaveURLCounter uint64
	SaveURLMock          mStorageMockSaveURL
}

// NewStorageMock returns a mock for mm_storage.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetOriginalURLMock = mStorageMockGetOriginalURL{mock: m}
	m.GetOriginalURLMock.callArgs = []*StorageMockGetOriginalURLParams{}

	m.GetShortURLMock = mStorageMockGetShortURL{mock: m}
	m.GetShortURLMock.callArgs = []*StorageMockGetShortURLParams{}

	m.SaveURLMock = mStorageMockSaveURL{mock: m}
	m.SaveURLMock.callArgs = []*StorageMockSaveURLParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockGetOriginalURL struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetOriginalURLExpectation
	expectations       []*StorageMockGetOriginalURLExpectation

	callArgs []*StorageMockGetOriginalURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetOriginalURLExpectation specifies expectation struct of the Storage.GetOriginalURL
type StorageMockGetOriginalURLExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetOriginalURLParams
	paramPtrs          *StorageMockGetOriginalURLParamPtrs
	expectationOrigins StorageMockGetOriginalURLExpectationOrigins
	results            *StorageMockGetOriginalURLResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetOriginalURLParams contains parameters of the Storage.GetOriginalURL
type StorageMockGetOriginalURLParams struct {
	ctx      context.Context
	shortURL string
}

// StorageMockGetOriginalURLParamPtrs contains pointers to parameters of the Storage.GetOriginalURL
type StorageMockGetOriginalURLParamPtrs struct {
	ctx      *context.Context
	shortURL *string
}

// StorageMockGetOriginalURLResults contains results of the Storage.GetOriginalURL
type StorageMockGetOriginalURLResults struct {
	s1  string
	err error
}

// StorageMockGetOriginalURLOrigins contains origins of expectations of the Storage.GetOriginalURL
type StorageMockGetOriginalURLExpectationOrigins struct {
	origin         string
	originCtx      string
	originShortURL string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOriginalURL *mStorageMockGetOriginalURL) Optional() *mStorageMockGetOriginalURL {
	mmGetOriginalURL.optional = true
	return mmGetOriginalURL
}

// Expect sets up expected params for Storage.GetOriginalURL
func (mmGetOriginalURL *mStorageMockGetOriginalURL) Expect(ctx context.Context, shortURL string) *mStorageMockGetOriginalURL {
	if mmGetOriginalURL.mock.funcGetOriginalURL != nil {
		mmGetOriginalURL.mock.t.Fatalf("StorageMock.GetOriginalURL mock is already set by Set")
	}

	if mmGetOriginalURL.defaultExpectation == nil {
		mmGetOriginalURL.defaultExpectation = &StorageMockGetOriginalURLExpectation{}
	}

	if mmGetOriginalURL.defaultExpectation.paramPtrs != nil {
		mmGetOriginalURL.mock.t.Fatalf("StorageMock.GetOriginalURL mock is already set by ExpectParams functions")
	}

	mmGetOriginalURL.defaultExpectation.params = &StorageMockGetOriginalURLParams{ctx, shortURL}
	mmGetOriginalURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOriginalURL.expectations {
		if minimock.Equal(e.params, mmGetOriginalURL.defaultExpectation.params) {
			mmGetOriginalURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOriginalURL.defaultExpectation.params)
		}
	}

	return mmGetOriginalURL
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetOriginalURL
func (mmGetOriginalURL *mStorageMockGetOriginalURL) ExpectCtxParam1(ctx context.Context) *mStorageMockGetOriginalURL {
	if mmGetOriginalURL.mock.funcGetOriginalURL != nil {
		mmGetOriginalURL.mock.t.Fatalf("StorageMock.GetOriginalURL mock is already set by Set")
	}

	if mmGetOriginalURL.defaultExpectation == nil {
		mmGetOriginalURL.defaultExpectation = &StorageMockGetOriginalURLExpectation{}
	}

	if mmGetOriginalURL.defaultExpectation.params != nil {
		mmGetOriginalURL.mock.t.Fatalf("StorageMock.GetOriginalURL mock is already set by Expect")
	}

	if mmGetOriginalURL.defaultExpectation.paramPtrs == nil {
		mmGetOriginalURL.defaultExpectation.paramPtrs = &StorageMockGetOriginalURLParamPtrs{}
	}
	mmGetOriginalURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOriginalURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOriginalURL
}

// ExpectShortURLParam2 sets up expected param shortURL for Storage.GetOriginalURL
func (mmGetOriginalURL *mStorageMockGetOriginalURL) ExpectShortURLParam2(shortURL string) *mStorageMockGetOriginalURL {
	if mmGetOriginalURL.mock.funcGetOriginalURL != nil {
		mmGetOriginalURL.mock.t.Fatalf("StorageMock.GetOriginalURL mock is already set by Set")
	}

	if mmGetOriginalURL.defaultExpectation == nil {
		mmGetOriginalURL.defaultExpectation = &StorageMockGetOriginalURLExpectation{}
	}

	if mmGetOriginalURL.defaultExpectation.params != nil {
		mmGetOriginalURL.mock.t.Fatalf("StorageMock.GetOriginalURL mock is already set by Expect")
	}

	if mmGetOriginalURL.defaultExpectation.paramPtrs == nil {
		mmGetOriginalURL.defaultExpectation.paramPtrs = &StorageMockGetOriginalURLParamPtrs{}
	}
	mmGetOriginalURL.defaultExpectation.paramPtrs.shortURL = &shortURL
	mmGetOriginalURL.defaultExpectation.expectationOrigins.originShortURL = minimock.CallerInfo(1)

	return mmGetOriginalURL
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetOriginalURL
func (mmGetOriginalURL *mStorageMockGetOriginalURL) Inspect(f func(ctx context.Context, shortURL string)) *mStorageMockGetOriginalURL {
	if mmGetOriginalURL.mock.inspectFuncGetOriginalURL != nil {
		mmGetOriginalURL.mock.t.Fatalf("Inspect function is already set for StorageMock.GetOriginalURL")
	}

	mmGetOriginalURL.mock.inspectFuncGetOriginalURL = f

	return mmGetOriginalURL
}

// Return sets up results that will be returned by Storage.GetOriginalURL
func (mmGetOriginalURL *mStorageMockGetOriginalURL) Return(s1 string, err error) *StorageMock {
	if mmGetOriginalURL.mock.funcGetOriginalURL != nil {
		mmGetOriginalURL.mock.t.Fatalf("StorageMock.GetOriginalURL mock is already set by Set")
	}

	if mmGetOriginalURL.defaultExpectation == nil {
		mmGetOriginalURL.defaultExpectation = &StorageMockGetOriginalURLExpectation{mock: mmGetOriginalURL.mock}
	}
	mmGetOriginalURL.defaultExpectation.results = &StorageMockGetOriginalURLResults{s1, err}
	mmGetOriginalURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOriginalURL.mock
}

// Set uses given function f to mock the Storage.GetOriginalURL method
func (mmGetOriginalURL *mStorageMockGetOriginalURL) Set(f func(ctx context.Context, shortURL string) (s1 string, err error)) *StorageMock {
	if mmGetOriginalURL.defaultExpectation != nil {
		mmGetOriginalURL.mock.t.Fatalf("Default expectation is already set for the Storage.GetOriginalURL method")
	}

	if len(mmGetOriginalURL.expectations) > 0 {
		mmGetOriginalURL.mock.t.Fatalf("Some expectations are already set for the Storage.GetOriginalURL method")
	}

	mmGetOriginalURL.mock.funcGetOriginalURL = f
	mmGetOriginalURL.mock.funcGetOriginalURLOrigin = minimock.CallerInfo(1)
	return mmGetOriginalURL.mock
}

// When sets expectation for the Storage.GetOriginalURL which will trigger the result defined by the following
// Then helper
func (mmGetOriginalURL *mStorageMockGetOriginalURL) When(ctx context.Context, shortURL string) *StorageMockGetOriginalURLExpectation {
	if mmGetOriginalURL.mock.funcGetOriginalURL != nil {
		mmGetOriginalURL.mock.t.Fatalf("StorageMock.GetOriginalURL mock is already set by Set")
	}

	expectation := &StorageMockGetOriginalURLExpectation{
		mock:               mmGetOriginalURL.mock,
		params:             &StorageMockGetOriginalURLParams{ctx, shortURL},
		expectationOrigins: StorageMockGetOriginalURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOriginalURL.expectations = append(mmGetOriginalURL.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetOriginalURL return parameters for the expectation previously defined by the When method
func (e *StorageMockGetOriginalURLExpectation) Then(s1 string, err error) *StorageMock {
	e.results = &StorageMockGetOriginalURLResults{s1, err}
	return e.mock
}

// Times sets number of times Storage.GetOriginalURL should be invoked
func (mmGetOriginalURL *mStorageMockGetOriginalURL) Times(n uint64) *mStorageMockGetOriginalURL {
	if n == 0 {
		mmGetOriginalURL.mock.t.Fatalf("Times of StorageMock.GetOriginalURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOriginalURL.expectedInvocations, n)
	mmGetOriginalURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOriginalURL
}

func (mmGetOriginalURL *mStorageMockGetOriginalURL) invocationsDone() bool {
	if len(mmGetOriginalURL.expectations) == 0 && mmGetOriginalURL.defaultExpectation == nil && mmGetOriginalURL.mock.funcGetOriginalURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOriginalURL.mock.afterGetOriginalURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOriginalURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOriginalURL implements mm_storage.Storage
func (mmGetOriginalURL *StorageMock) GetOriginalURL(ctx context.Context, shortURL string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetOriginalURL.beforeGetOriginalURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOriginalURL.afterGetOriginalURLCounter, 1)

	mmGetOriginalURL.t.Helper()

	if mmGetOriginalURL.inspectFuncGetOriginalURL != nil {
		mmGetOriginalURL.inspectFuncGetOriginalURL(ctx, shortURL)
	}

	mm_params := StorageMockGetOriginalURLParams{ctx, shortURL}

	// Record call args
	mmGetOriginalURL.GetOriginalURLMock.mutex.Lock()
	mmGetOriginalURL.GetOriginalURLMock.callArgs = append(mmGetOriginalURL.GetOriginalURLMock.callArgs, &mm_params)
	mmGetOriginalURL.GetOriginalURLMock.mutex.Unlock()

	for _, e := range mmGetOriginalURL.GetOriginalURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetOriginalURL.GetOriginalURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOriginalURL.GetOriginalURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOriginalURL.GetOriginalURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetOriginalURL.GetOriginalURLMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetOriginalURLParams{ctx, shortURL}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOriginalURL.t.Errorf("StorageMock.GetOriginalURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOriginalURL.GetOriginalURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.shortURL != nil && !minimock.Equal(*mm_want_ptrs.shortURL, mm_got.shortURL) {
				mmGetOriginalURL.t.Errorf("StorageMock.GetOriginalURL got unexpected parameter shortURL, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOriginalURL.GetOriginalURLMock.defaultExpectation.expectationOrigins.originShortURL, *mm_want_ptrs.shortURL, mm_got.shortURL, minimock.Diff(*mm_want_ptrs.shortURL, mm_got.shortURL))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOriginalURL.t.Errorf("StorageMock.GetOriginalURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOriginalURL.GetOriginalURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOriginalURL.GetOriginalURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOriginalURL.t.Fatal("No results are set for the StorageMock.GetOriginalURL")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetOriginalURL.funcGetOriginalURL != nil {
		return mmGetOriginalURL.funcGetOriginalURL(ctx, shortURL)
	}
	mmGetOriginalURL.t.Fatalf("Unexpected call to StorageMock.GetOriginalURL. %v %v", ctx, shortURL)
	return
}

// GetOriginalURLAfterCounter returns a count of finished StorageMock.GetOriginalURL invocations
func (mmGetOriginalURL *StorageMock) GetOriginalURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOriginalURL.afterGetOriginalURLCounter)
}

// GetOriginalURLBeforeCounter returns a count of StorageMock.GetOriginalURL invocations
func (mmGetOriginalURL *StorageMock) GetOriginalURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOriginalURL.beforeGetOriginalURLCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetOriginalURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOriginalURL *mStorageMockGetOriginalURL) Calls() []*StorageMockGetOriginalURLParams {
	mmGetOriginalURL.mutex.RLock()

	argCopy := make([]*StorageMockGetOriginalURLParams, len(mmGetOriginalURL.callArgs))
	copy(argCopy, mmGetOriginalURL.callArgs)

	mmGetOriginalURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetOriginalURLDone returns true if the count of the GetOriginalURL invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetOriginalURLDone() bool {
	if m.GetOriginalURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOriginalURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOriginalURLMock.invocationsDone()
}

// MinimockGetOriginalURLInspect logs each unmet expectation
func (m *StorageMock) MinimockGetOriginalURLInspect() {
	for _, e := range m.GetOriginalURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetOriginalURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOriginalURLCounter := mm_atomic.LoadUint64(&m.afterGetOriginalURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOriginalURLMock.defaultExpectation != nil && afterGetOriginalURLCounter < 1 {
		if m.GetOriginalURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetOriginalURL at\n%s", m.GetOriginalURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetOriginalURL at\n%s with params: %#v", m.GetOriginalURLMock.defaultExpectation.expectationOrigins.origin, *m.GetOriginalURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOriginalURL != nil && afterGetOriginalURLCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetOriginalURL at\n%s", m.funcGetOriginalURLOrigin)
	}

	if !m.GetOriginalURLMock.invocationsDone() && afterGetOriginalURLCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetOriginalURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOriginalURLMock.expectedInvocations), m.GetOriginalURLMock.expectedInvocationsOrigin, afterGetOriginalURLCounter)
	}
}

type mStorageMockGetShortURL struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetShortURLExpectation
	expectations       []*StorageMockGetShortURLExpectation

	callArgs []*StorageMockGetShortURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetShortURLExpectation specifies expectation struct of the Storage.GetShortURL
type StorageMockGetShortURLExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetShortURLParams
	paramPtrs          *StorageMockGetShortURLParamPtrs
	expectationOrigins StorageMockGetShortURLExpectationOrigins
	results            *StorageMockGetShortURLResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetShortURLParams contains parameters of the Storage.GetShortURL
type StorageMockGetShortURLParams struct {
	ctx         context.Context
	originalURL string
}

// StorageMockGetShortURLParamPtrs contains pointers to parameters of the Storage.GetShortURL
type StorageMockGetShortURLParamPtrs struct {
	ctx         *context.Context
	originalURL *string
}

// StorageMockGetShortURLResults contains results of the Storage.GetShortURL
type StorageMockGetShortURLResults struct {
	s1  string
	err error
}

// StorageMockGetShortURLOrigins contains origins of expectations of the Storage.GetShortURL
type StorageMockGetShortURLExpectationOrigins struct {
	origin            string
	originCtx         string
	originOriginalURL string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetShortURL *mStorageMockGetShortURL) Optional() *mStorageMockGetShortURL {
	mmGetShortURL.optional = true
	return mmGetShortURL
}

// Expect sets up expected params for Storage.GetShortURL
func (mmGetShortURL *mStorageMockGetShortURL) Expect(ctx context.Context, originalURL string) *mStorageMockGetShortURL {
	if mmGetShortURL.mock.funcGetShortURL != nil {
		mmGetShortURL.mock.t.Fatalf("StorageMock.GetShortURL mock is already set by Set")
	}

	if mmGetShortURL.defaultExpectation == nil {
		mmGetShortURL.defaultExpectation = &StorageMockGetShortURLExpectation{}
	}

	if mmGetShortURL.defaultExpectation.paramPtrs != nil {
		mmGetShortURL.mock.t.Fatalf("StorageMock.GetShortURL mock is already set by ExpectParams functions")
	}

	mmGetShortURL.defaultExpectation.params = &StorageMockGetShortURLParams{ctx, originalURL}
	mmGetShortURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetShortURL.expectations {
		if minimock.Equal(e.params, mmGetShortURL.defaultExpectation.params) {
			mmGetShortURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetShortURL.defaultExpectation.params)
		}
	}

	return mmGetShortURL
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetShortURL
func (mmGetShortURL *mStorageMockGetShortURL) ExpectCtxParam1(ctx context.Context) *mStorageMockGetShortURL {
	if mmGetShortURL.mock.funcGetShortURL != nil {
		mmGetShortURL.mock.t.Fatalf("StorageMock.GetShortURL mock is already set by Set")
	}

	if mmGetShortURL.defaultExpectation == nil {
		mmGetShortURL.defaultExpectation = &StorageMockGetShortURLExpectation{}
	}

	if mmGetShortURL.defaultExpectation.params != nil {
		mmGetShortURL.mock.t.Fatalf("StorageMock.GetShortURL mock is already set by Expect")
	}

	if mmGetShortURL.defaultExpectation.paramPtrs == nil {
		mmGetShortURL.defaultExpectation.paramPtrs = &StorageMockGetShortURLParamPtrs{}
	}
	mmGetShortURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetShortURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetShortURL
}

// ExpectOriginalURLParam2 sets up expected param originalURL for Storage.GetShortURL
func (mmGetShortURL *mStorageMockGetShortURL) ExpectOriginalURLParam2(originalURL string) *mStorageMockGetShortURL {
	if mmGetShortURL.mock.funcGetShortURL != nil {
		mmGetShortURL.mock.t.Fatalf("StorageMock.GetShortURL mock is already set by Set")
	}

	if mmGetShortURL.defaultExpectation == nil {
		mmGetShortURL.defaultExpectation = &StorageMockGetShortURLExpectation{}
	}

	if mmGetShortURL.defaultExpectation.params != nil {
		mmGetShortURL.mock.t.Fatalf("StorageMock.GetShortURL mock is already set by Expect")
	}

	if mmGetShortURL.defaultExpectation.paramPtrs == nil {
		mmGetShortURL.defaultExpectation.paramPtrs = &StorageMockGetShortURLParamPtrs{}
	}
	mmGetShortURL.defaultExpectation.paramPtrs.originalURL = &originalURL
	mmGetShortURL.defaultExpectation.expectationOrigins.originOriginalURL = minimock.CallerInfo(1)

	return mmGetShortURL
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetShortURL
func (mmGetShortURL *mStorageMockGetShortURL) Inspect(f func(ctx context.Context, originalURL string)) *mStorageMockGetShortURL {
	if mmGetShortURL.mock.inspectFuncGetShortURL != nil {
		mmGetShortURL.mock.t.Fatalf("Inspect function is already set for StorageMock.GetShortURL")
	}

	mmGetShortURL.mock.inspectFuncGetShortURL = f

	return mmGetShortURL
}

// Return sets up results that will be returned by Storage.GetShortURL
func (mmGetShortURL *mStorageMockGetShortURL) Return(s1 string, err error) *StorageMock {
	if mmGetShortURL.mock.funcGetShortURL != nil {
		mmGetShortURL.mock.t.Fatalf("StorageMock.GetShortURL mock is already set by Set")
	}

	if mmGetShortURL.defaultExpectation == nil {
		mmGetShortURL.defaultExpectation = &StorageMockGetShortURLExpectation{mock: mmGetShortURL.mock}
	}
	mmGetShortURL.defaultExpectation.results = &StorageMockGetShortURLResults{s1, err}
	mmGetShortURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetShortURL.mock
}

// Set uses given function f to mock the Storage.GetShortURL method
func (mmGetShortURL *mStorageMockGetShortURL) Set(f func(ctx context.Context, originalURL string) (s1 string, err error)) *StorageMock {
	if mmGetShortURL.defaultExpectation != nil {
		mmGetShortURL.mock.t.Fatalf("Default expectation is already set for the Storage.GetShortURL method")
	}

	if len(mmGetShortURL.expectations) > 0 {
		mmGetShortURL.mock.t.Fatalf("Some expectations are already set for the Storage.GetShortURL method")
	}

	mmGetShortURL.mock.funcGetShortURL = f
	mmGetShortURL.mock.funcGetShortURLOrigin = minimock.CallerInfo(1)
	return mmGetShortURL.mock
}

// When sets expectation for the Storage.GetShortURL which will trigger the result defined by the following
// Then helper
func (mmGetShortURL *mStorageMockGetShortURL) When(ctx context.Context, originalURL string) *StorageMockGetShortURLExpectation {
	if mmGetShortURL.mock.funcGetShortURL != nil {
		mmGetShortURL.mock.t.Fatalf("StorageMock.GetShortURL mock is already set by Set")
	}

	expectation := &StorageMockGetShortURLExpectation{
		mock:               mmGetShortURL.mock,
		params:             &StorageMockGetShortURLParams{ctx, originalURL},
		expectationOrigins: StorageMockGetShortURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetShortURL.expectations = append(mmGetShortURL.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetShortURL return parameters for the expectation previously defined by the When method
func (e *StorageMockGetShortURLExpectation) Then(s1 string, err error) *StorageMock {
	e.results = &StorageMockGetShortURLResults{s1, err}
	return e.mock
}

// Times sets number of times Storage.GetShortURL should be invoked
func (mmGetShortURL *mStorageMockGetShortURL) Times(n uint64) *mStorageMockGetShortURL {
	if n == 0 {
		mmGetShortURL.mock.t.Fatalf("Times of StorageMock.GetShortURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetShortURL.expectedInvocations, n)
	mmGetShortURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetShortURL
}

func (mmGetShortURL *mStorageMockGetShortURL) invocationsDone() bool {
	if len(mmGetShortURL.expectations) == 0 && mmGetShortURL.defaultExpectation == nil && mmGetShortURL.mock.funcGetShortURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetShortURL.mock.afterGetShortURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetShortURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetShortURL implements mm_storage.Storage
func (mmGetShortURL *StorageMock) GetShortURL(ctx context.Context, originalURL string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetShortURL.beforeGetShortURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetShortURL.afterGetShortURLCounter, 1)

	mmGetShortURL.t.Helper()

	if mmGetShortURL.inspectFuncGetShortURL != nil {
		mmGetShortURL.inspectFuncGetShortURL(ctx, originalURL)
	}

	mm_params := StorageMockGetShortURLParams{ctx, originalURL}

	// Record call args
	mmGetShortURL.GetShortURLMock.mutex.Lock()
	mmGetShortURL.GetShortURLMock.callArgs = append(mmGetShortURL.GetShortURLMock.callArgs, &mm_params)
	mmGetShortURL.GetShortURLMock.mutex.Unlock()

	for _, e := range mmGetShortURL.GetShortURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetShortURL.GetShortURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetShortURL.GetShortURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetShortURL.GetShortURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetShortURL.GetShortURLMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetShortURLParams{ctx, originalURL}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetShortURL.t.Errorf("StorageMock.GetShortURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetShortURL.GetShortURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.originalURL != nil && !minimock.Equal(*mm_want_ptrs.originalURL, mm_got.originalURL) {
				mmGetShortURL.t.Errorf("StorageMock.GetShortURL got unexpected parameter originalURL, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetShortURL.GetShortURLMock.defaultExpectation.expectationOrigins.originOriginalURL, *mm_want_ptrs.originalURL, mm_got.originalURL, minimock.Diff(*mm_want_ptrs.originalURL, mm_got.originalURL))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetShortURL.t.Errorf("StorageMock.GetShortURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetShortURL.GetShortURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetShortURL.GetShortURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetShortURL.t.Fatal("No results are set for the StorageMock.GetShortURL")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetShortURL.funcGetShortURL != nil {
		return mmGetShortURL.funcGetShortURL(ctx, originalURL)
	}
	mmGetShortURL.t.Fatalf("Unexpected call to StorageMock.GetShortURL. %v %v", ctx, originalURL)
	return
}

// GetShortURLAfterCounter returns a count of finished StorageMock.GetShortURL invocations
func (mmGetShortURL *StorageMock) GetShortURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetShortURL.afterGetShortURLCounter)
}

// GetShortURLBeforeCounter returns a count of StorageMock.GetShortURL invocations
func (mmGetShortURL *StorageMock) GetShortURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetShortURL.beforeGetShortURLCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetShortURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetShortURL *mStorageMockGetShortURL) Calls() []*StorageMockGetShortURLParams {
	mmGetShortURL.mutex.RLock()

	argCopy := make([]*StorageMockGetShortURLParams, len(mmGetShortURL.callArgs))
	copy(argCopy, mmGetShortURL.callArgs)

	mmGetShortURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetShortURLDone returns true if the count of the GetShortURL invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetShortURLDone() bool {
	if m.GetShortURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetShortURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetShortURLMock.invocationsDone()
}

// MinimockGetShortURLInspect logs each unmet expectation
func (m *StorageMock) MinimockGetShortURLInspect() {
	for _, e := range m.GetShortURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetShortURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetShortURLCounter := mm_atomic.LoadUint64(&m.afterGetShortURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetShortURLMock.defaultExpectation != nil && afterGetShortURLCounter < 1 {
		if m.GetShortURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetShortURL at\n%s", m.GetShortURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetShortURL at\n%s with params: %#v", m.GetShortURLMock.defaultExpectation.expectationOrigins.origin, *m.GetShortURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetShortURL != nil && afterGetShortURLCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetShortURL at\n%s", m.funcGetShortURLOrigin)
	}

	if !m.GetShortURLMock.invocationsDone() && afterGetShortURLCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetShortURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetShortURLMock.expectedInvocations), m.GetShortURLMock.expectedInvocationsOrigin, afterGetShortURLCounter)
	}
}

type mStorageMockSaveURL struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockSaveURLExpectation
	expectations       []*StorageMockSaveURLExpectation

	callArgs []*StorageMockSaveURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockSaveURLExpectation specifies expectation struct of the Storage.SaveURL
type StorageMockSaveURLExpectation struct {
	mock               *StorageMock
	params             *StorageMockSaveURLParams
	paramPtrs          *StorageMockSaveURLParamPtrs
	expectationOrigins StorageMockSaveURLExpectationOrigins
	results            *StorageMockSaveURLResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockSaveURLParams contains parameters of the Storage.SaveURL
type StorageMockSaveURLParams struct {
	ctx         context.Context
	originalURL string
	shortURL    string
}

// StorageMockSaveURLParamPtrs contains pointers to parameters of the Storage.SaveURL
type StorageMockSaveURLParamPtrs struct {
	ctx         *context.Context
	originalURL *string
	shortURL    *string
}

// StorageMockSaveURLResults contains results of the Storage.SaveURL
type StorageMockSaveURLResults struct {
	err error
}

// StorageMockSaveURLOrigins contains origins of expectations of the Storage.SaveURL
type StorageMockSaveURLExpectationOrigins struct {
	origin            string
	originCtx         string
	originOriginalURL string
	originShortURL    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveURL *mStorageMockSaveURL) Optional() *mStorageMockSaveURL {
	mmSaveURL.optional = true
	return mmSaveURL
}

// Expect sets up expected params for Storage.SaveURL
func (mmSaveURL *mStorageMockSaveURL) Expect(ctx context.Context, originalURL string, shortURL string) *mStorageMockSaveURL {
	if mmSaveURL.mock.funcSaveURL != nil {
		mmSaveURL.mock.t.Fatalf("StorageMock.SaveURL mock is already set by Set")
	}

	if mmSaveURL.defaultExpectation == nil {
		mmSaveURL.defaultExpectation = &StorageMockSaveURLExpectation{}
	}

	if mmSaveURL.defaultExpectation.paramPtrs != nil {
		mmSaveURL.mock.t.Fatalf("StorageMock.SaveURL mock is already set by ExpectParams functions")
	}

	mmSaveURL.defaultExpectation.params = &StorageMockSaveURLParams{ctx, originalURL, shortURL}
	mmSaveURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveURL.expectations {
		if minimock.Equal(e.params, mmSaveURL.defaultExpectation.params) {
			mmSaveURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveURL.defaultExpectation.params)
		}
	}

	return mmSaveURL
}

// ExpectCtxParam1 sets up expected param ctx for Storage.SaveURL
func (mmSaveURL *mStorageMockSaveURL) ExpectCtxParam1(ctx context.Context) *mStorageMockSaveURL {
	if mmSaveURL.mock.funcSaveURL != nil {
		mmSaveURL.mock.t.Fatalf("StorageMock.SaveURL mock is already set by Set")
	}

	if mmSaveURL.defaultExpectation == nil {
		mmSaveURL.defaultExpectation = &StorageMockSaveURLExpectation{}
	}

	if mmSaveURL.defaultExpectation.params != nil {
		mmSaveURL.mock.t.Fatalf("StorageMock.SaveURL mock is already set by Expect")
	}

	if mmSaveURL.defaultExpectation.paramPtrs == nil {
		mmSaveURL.defaultExpectation.paramPtrs = &StorageMockSaveURLParamPtrs{}
	}
	mmSaveURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveURL
}

// ExpectOriginalURLParam2 sets up expected param originalURL for Storage.SaveURL
func (mmSaveURL *mStorageMockSaveURL) ExpectOriginalURLParam2(originalURL string) *mStorageMockSaveURL {
	if mmSaveURL.mock.funcSaveURL != nil {
		mmSaveURL.mock.t.Fatalf("StorageMock.SaveURL mock is already set by Set")
	}

	if mmSaveURL.defaultExpectation == nil {
		mmSaveURL.defaultExpectation = &StorageMockSaveURLExpectation{}
	}

	if mmSaveURL.defaultExpectation.params != nil {
		mmSaveURL.mock.t.Fatalf("StorageMock.SaveURL mock is already set by Expect")
	}

	if mmSaveURL.defaultExpectation.paramPtrs == nil {
		mmSaveURL.defaultExpectation.paramPtrs = &StorageMockSaveURLParamPtrs{}
	}
	mmSaveURL.defaultExpectation.paramPtrs.originalURL = &originalURL
	mmSaveURL.defaultExpectation.expectationOrigins.originOriginalURL = minimock.CallerInfo(1)

	return mmSaveURL
}

// ExpectShortURLParam3 sets up expected param shortURL for Storage.SaveURL
func (mmSaveURL *mStorageMockSaveURL) ExpectShortURLParam3(shortURL string) *mStorageMockSaveURL {
	if mmSaveURL.mock.funcSaveURL != nil {
		mmSaveURL.mock.t.Fatalf("StorageMock.SaveURL mock is already set by Set")
	}

	if mmSaveURL.defaultExpectation == nil {
		mmSaveURL.defaultExpectation = &StorageMockSaveURLExpectation{}
	}

	if mmSaveURL.defaultExpectation.params != nil {
		mmSaveURL.mock.t.Fatalf("StorageMock.SaveURL mock is already set by Expect")
	}

	if mmSaveURL.defaultExpectation.paramPtrs == nil {
		mmSaveURL.defaultExpectation.paramPtrs = &StorageMockSaveURLParamPtrs{}
	}
	mmSaveURL.defaultExpectation.paramPtrs.shortURL = &shortURL
	mmSaveURL.defaultExpectation.expectationOrigins.originShortURL = minimock.CallerInfo(1)

	return mmSaveURL
}

// Inspect accepts an inspector function that has same arguments as the Storage.SaveURL
func (mmSaveURL *mStorageMockSaveURL) Inspect(f func(ctx context.Context, originalURL string, shortURL string)) *mStorageMockSaveURL {
	if mmSaveURL.mock.inspectFuncSaveURL != nil {
		mmSaveURL.mock.t.Fatalf("Inspect function is already set for StorageMock.SaveURL")
	}

	mmSaveURL.mock.inspectFuncSaveURL = f

	return mmSaveURL
}

// Return sets up results that will be returned by Storage.SaveURL
func (mmSaveURL *mStorageMockSaveURL) Return(err error) *StorageMock {
	if mmSaveURL.mock.funcSaveURL != nil {
		mmSaveURL.mock.t.Fatalf("StorageMock.SaveURL mock is already set by Set")
	}

	if mmSaveURL.defaultExpectation == nil {
		mmSaveURL.defaultExpectation = &StorageMockSaveURLExpectation{mock: mmSaveURL.mock}
	}
	mmSaveURL.defaultExpectation.results = &StorageMockSaveURLResults{err}
	mmSaveURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveURL.mock
}

// Set uses given function f to mock the Storage.SaveURL method
func (mmSaveURL *mStorageMockSaveURL) Set(f func(ctx context.Context, originalURL string, shortURL string) (err error)) *StorageMock {
	if mmSaveURL.defaultExpectation != nil {
		mmSaveURL.mock.t.Fatalf("Default expectation is already set for the Storage.SaveURL method")
	}

	if len(mmSaveURL.expectations) > 0 {
		mmSaveURL.mock.t.Fatalf("Some expectations are already set for the Storage.SaveURL method")
	}

	mmSaveURL.mock.funcSaveURL = f
	mmSaveURL.mock.funcSaveURLOrigin = minimock.CallerInfo(1)
	return mmSaveURL.mock
}

// When sets expectation for the Storage.SaveURL which will trigger the result defined by the following
// Then helper
func (mmSaveURL *mStorageMockSaveURL) When(ctx context.Context, originalURL string, shortURL string) *StorageMockSaveURLExpectation {
	if mmSaveURL.mock.funcSaveURL != nil {
		mmSaveURL.mock.t.Fatalf("StorageMock.SaveURL mock is already set by Set")
	}

	expectation := &StorageMockSaveURLExpectation{
		mock:               mmSaveURL.mock,
		params:             &StorageMockSaveURLParams{ctx, originalURL, shortURL},
		expectationOrigins: StorageMockSaveURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveURL.expectations = append(mmSaveURL.expectations, expectation)
	return expectation
}

// Then sets up Storage.SaveURL return parameters for the expectation previously defined by the When method
func (e *StorageMockSaveURLExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockSaveURLResults{err}
	return e.mock
}

// Times sets number of times Storage.SaveURL should be invoked
func (mmSaveURL *mStorageMockSaveURL) Times(n uint64) *mStorageMockSaveURL {
	if n == 0 {
		mmSaveURL.mock.t.Fatalf("Times of StorageMock.SaveURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveURL.expectedInvocations, n)
	mmSaveURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveURL
}

func (mmSaveURL *mStorageMockSaveURL) invocationsDone() bool {
	if len(mmSaveURL.expectations) == 0 && mmSaveURL.defaultExpectation == nil && mmSaveURL.mock.funcSaveURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveURL.mock.afterSaveURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveURL implements mm_storage.Storage
func (mmSaveURL *StorageMock) SaveURL(ctx context.Context, originalURL string, shortURL string) (err error) {
	mm_atomic.AddUint64(&mmSaveURL.beforeSaveURLCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveURL.afterSaveURLCounter, 1)

	mmSaveURL.t.Helper()

	if mmSaveURL.inspectFuncSaveURL != nil {
		mmSaveURL.inspectFuncSaveURL(ctx, originalURL, shortURL)
	}

	mm_params := StorageMockSaveURLParams{ctx, originalURL, shortURL}

	// Record call args
	mmSaveURL.SaveURLMock.mutex.Lock()
	mmSaveURL.SaveURLMock.callArgs = append(mmSaveURL.SaveURLMock.callArgs, &mm_params)
	mmSaveURL.SaveURLMock.mutex.Unlock()

	for _, e := range mmSaveURL.SaveURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveURL.SaveURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveURL.SaveURLMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveURL.SaveURLMock.defaultExpectation.params
		mm_want_ptrs := mmSaveURL.SaveURLMock.defaultExpectation.paramPtrs

		mm_got := StorageMockSaveURLParams{ctx, originalURL, shortURL}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveURL.t.Errorf("StorageMock.SaveURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveURL.SaveURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.originalURL != nil && !minimock.Equal(*mm_want_ptrs.originalURL, mm_got.originalURL) {
				mmSaveURL.t.Errorf("StorageMock.SaveURL got unexpected parameter originalURL, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveURL.SaveURLMock.defaultExpectation.expectationOrigins.originOriginalURL, *mm_want_ptrs.originalURL, mm_got.originalURL, minimock.Diff(*mm_want_ptrs.originalURL, mm_got.originalURL))
			}

			if mm_want_ptrs.shortURL != nil && !minimock.Equal(*mm_want_ptrs.shortURL, mm_got.shortURL) {
				mmSaveURL.t.Errorf("StorageMock.SaveURL got unexpected parameter shortURL, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveURL.SaveURLMock.defaultExpectation.expectationOrigins.originShortURL, *mm_want_ptrs.shortURL, mm_got.shortURL, minimock.Diff(*mm_want_ptrs.shortURL, mm_got.shortURL))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveURL.t.Errorf("StorageMock.SaveURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveURL.SaveURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveURL.SaveURLMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveURL.t.Fatal("No results are set for the StorageMock.SaveURL")
		}
		return (*mm_results).err
	}
	if mmSaveURL.funcSaveURL != nil {
		return mmSaveURL.funcSaveURL(ctx, originalURL, shortURL)
	}
	mmSaveURL.t.Fatalf("Unexpected call to StorageMock.SaveURL. %v %v %v", ctx, originalURL, shortURL)
	return
}

// SaveURLAfterCounter returns a count of finished StorageMock.SaveURL invocations
func (mmSaveURL *StorageMock) SaveURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveURL.afterSaveURLCounter)
}

// SaveURLBeforeCounter returns a count of StorageMock.SaveURL invocations
func (mmSaveURL *StorageMock) SaveURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveURL.beforeSaveURLCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SaveURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveURL *mStorageMockSaveURL) Calls() []*StorageMockSaveURLParams {
	mmSaveURL.mutex.RLock()

	argCopy := make([]*StorageMockSaveURLParams, len(mmSaveURL.callArgs))
	copy(argCopy, mmSaveURL.callArgs)

	mmSaveURL.mutex.RUnlock()

	return argCopy
}

// MinimockSaveURLDone returns true if the count of the SaveURL invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSaveURLDone() bool {
	if m.SaveURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveURLMock.invocationsDone()
}

// MinimockSaveURLInspect logs each unmet expectation
func (m *StorageMock) MinimockSaveURLInspect() {
	for _, e := range m.SaveURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SaveURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveURLCounter := mm_atomic.LoadUint64(&m.afterSaveURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveURLMock.defaultExpectation != nil && afterSaveURLCounter < 1 {
		if m.SaveURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.SaveURL at\n%s", m.SaveURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.SaveURL at\n%s with params: %#v", m.SaveURLMock.defaultExpectation.expectationOrigins.origin, *m.SaveURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveURL != nil && afterSaveURLCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.SaveURL at\n%s", m.funcSaveURLOrigin)
	}

	if !m.SaveURLMock.invocationsDone() && afterSaveURLCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.SaveURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveURLMock.expectedInvocations), m.SaveURLMock.expectedInvocationsOrigin, afterSaveURLCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetOriginalURLInspect()

			m.MinimockGetShortURLInspect()

			m.MinimockSaveURLInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetOriginalURLDone() &&
		m.MinimockGetShortURLDone() &&
		m.MinimockSaveURLDone()
}
